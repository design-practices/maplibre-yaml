---
title: Astro Integration
description: Use maplibre-yaml in Astro sites and components
---

import {
  Aside,
  Steps,
  Tabs,
  TabItem,
  Card,
  CardGrid,
} from "@astrojs/starlight/components";

Astro is a natural fit for maplibre-yaml - both embrace configuration-driven approaches. This guide covers integrating maps into Astro sites, from simple page embeds to reusable components.

<Aside type="tip" title="Recommended: Use the src Attribute">
  The simplest approach is to place YAML files in the `/public` directory and use the `src` attribute. The web component handles loading and parsing automatically.
</Aside>

## Quick Start

Get a map in your Astro site in 5 minutes.

<Steps>

1. **Install dependencies**

   ```bash
   pnpm add @maplibre-yaml/core maplibre-gl
   ```

2. **Create a map configuration file**

   Create `public/configs/hero-map.yaml`:

   ```yaml
   type: map
   id: hero-map
   config:
     center: [-74.006, 40.7128]
     zoom: 12
     mapStyle: "https://demotiles.maplibre.org/style.json"
   layers:
     - id: marker
       type: circle
       source:
         type: geojson
         data:
           type: FeatureCollection
           features:
             - type: Feature
               geometry:
                 type: Point
                 coordinates: [-74.006, 40.7128]
               properties:
                 name: "New York City"
       paint:
         circle-radius: 12
         circle-color: "#3b82f6"
         circle-stroke-width: 2
         circle-stroke-color: "#ffffff"
   ```

3. **Create a Map component**

   Create `src/components/Map.astro`:

   ```astro
   ---
   interface Props {
     src: string;
     height?: string;
     class?: string;
   }

   const { src, height = '400px', class: className } = Astro.props;
   ---

   <ml-map
     src={src}
     style={`height: ${height}; display: block;`}
     class={className}
   />

   <script>
     import '@maplibre-yaml/core/register';
     import 'maplibre-gl/dist/maplibre-gl.css';
   </script>

   <style>
     ml-map {
       width: 100%;
       border-radius: 8px;
       overflow: hidden;
     }
   </style>
   ```

4. **Use in a page**

   ```astro
   ---
   // src/pages/index.astro
   import Layout from '../layouts/Layout.astro';
   import Map from '../components/Map.astro';
   ---

   <Layout title="Home">
     <h1>Welcome</h1>
     <Map src="/configs/hero-map.yaml" height="500px" />
   </Layout>
   ```

</Steps>

## Component Patterns

### Pattern 1: External YAML with src Attribute (Recommended)

The simplest pattern - let the web component handle everything. Place YAML files in the `/public` directory and reference them with the `src` attribute.

**File structure:**

```
public/
├── configs/
│   ├── hero-map.yaml
│   ├── contact-map.yaml
│   └── locations-map.yaml
src/
├── components/
│   └── Map.astro
└── pages/
    └── index.astro
```

**Map.astro:**

```astro
---
interface Props {
  src: string;
  height?: string;
}

const { src, height = '400px' } = Astro.props;
---

<ml-map src={src} style={`height: ${height}; display: block;`} />

<script>
  import '@maplibre-yaml/core/register';
  import 'maplibre-gl/dist/maplibre-gl.css';
</script>
```

**Usage:**

```astro
<Map src="/configs/hero-map.yaml" />
<Map src="/configs/contact-map.yaml" height="300px" />
```

**Benefits:**

- ✅ Simplest possible implementation
- ✅ No build-time parsing needed
- ✅ YAML files are easy to edit
- ✅ Clear separation of configuration and presentation
- ✅ Works with any static file server
- ✅ No template literal whitespace issues

### Pattern 2: External YAML with Build-Time Parsing

For projects that want build-time validation, you can parse YAML during the build:

**File structure:**

```
src/
├── components/
│   └── Map.astro
├── configs/
│   ├── hero-map.yaml
│   ├── contact-map.yaml
│   └── locations-map.yaml
└── pages/
    └── index.astro
```

**Map.astro:**

```astro
---
import { YAMLParser } from '@maplibre-yaml/core';

interface Props {
  configPath: string;
  height?: string;
}

const { configPath, height = '400px' } = Astro.props;

// Import all YAML files at build time
const yamlFiles = import.meta.glob('/src/configs/**/*.yaml', {
  as: 'raw',
  eager: true
});

const yamlContent = yamlFiles[configPath];

if (!yamlContent) {
  const available = Object.keys(yamlFiles).join(', ');
  throw new Error(`Config not found: ${configPath}. Available: ${available}`);
}

const result = YAMLParser.safeParseMapBlock(yamlContent);

if (!result.success) {
  console.error('YAML parse errors:', result.errors);
  throw new Error(`Invalid config ${configPath}: ${result.errors[0].message}`);
}

const configJson = JSON.stringify(result.data);
---

<ml-map style={`height: ${height}; display: block;`} config={configJson} />

<script>
  import '@maplibre-yaml/core/register';
  import 'maplibre-gl/dist/maplibre-gl.css';
</script>
```

**Usage:**

```astro
<Map configPath="/src/configs/hero-map.yaml" />
<Map configPath="/src/configs/contact-map.yaml" height="300px" />
```

**Benefits:**

- ✅ Build-time parsing catches errors early
- ✅ YAML validation during development
- ✅ Configuration bundled with the build

**Tradeoffs:**

- ⚠️ More complex component code
- ⚠️ Requires rebuild to see YAML changes

### Pattern 3: Inline Configuration (Not Recommended)

For simple, one-off maps, you can inline configuration. However, this approach has significant drawbacks and is generally not recommended.

<Aside type="caution" title="Use Pattern 1 Instead">
  Template literal whitespace handling can break YAML formatting. The `src` attribute pattern (Pattern 1) avoids all these issues.
</Aside>

**InlineMap.astro:**

```astro
---
import { YAMLParser } from '@maplibre-yaml/core';

interface Props {
  yaml: string;
  height?: string;
}

const { yaml, height = '400px' } = Astro.props;

const result = YAMLParser.safeParseMapBlock(yaml);

if (!result.success) {
  console.error('Parse errors:', result.errors);
}

const configJson = result.success ? JSON.stringify(result.data) : null;
const error = result.success ? null : result.errors;
---

{error ? (
  <div class="map-error">
    <strong>Configuration Error</strong>
    <pre>{JSON.stringify(error, null, 2)}</pre>
  </div>
) : (
  <ml-map style={`height: ${height}; display: block;`} config={configJson} />
)}

<script>
  import '@maplibre-yaml/core/register';
  import 'maplibre-gl/dist/maplibre-gl.css';
</script>

<style>
  .map-error {
    padding: 20px;
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-radius: 8px;
    color: #dc2626;
  }
  .map-error pre {
    margin-top: 10px;
    font-size: 12px;
    overflow-x: auto;
  }
</style>
```

**Usage in page:**

```astro
---
import InlineMap from '../components/InlineMap.astro';

// ⚠️ MUST start content immediately after backtick
const simpleMapYaml = `type: map
id: simple-map
config:
  center: [-74.006, 40.7128]
  zoom: 12
  mapStyle: "https://demotiles.maplibre.org/style.json"
layers: []`;
---

<InlineMap yaml={simpleMapYaml} height="300px" />
```

### Pattern 4: Using src Attribute in MDX

In MDX files (like documentation), use the `src` attribute pattern for the cleanest approach:

**guide.mdx:**

```mdx
---
title: Map Guide
---

import Map from "../../components/Map.astro";

## Live Earthquake Data

Here's a map showing recent earthquakes:

<Map src="/configs/earthquake-map.yaml" height="400px" />

The data refreshes from the USGS API.
```

**public/configs/earthquake-map.yaml:**

```yaml
type: map
id: earthquake-demo
config:
  center: [-120, 37]
  zoom: 4
  mapStyle: "https://demotiles.maplibre.org/style.json"
layers:
  - id: quakes
    type: circle
    source:
      type: geojson
      url: "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson"
    paint:
      circle-radius: 6
      circle-color: "#ef4444"
```

<Aside type="tip">
  This pattern keeps your MDX clean and readable, with map configurations in separate YAML files that are easy to maintain.
</Aside>

## Advanced: Interactive Map Component

A full-featured component with events and controls using the `src` pattern:

**InteractiveMap.astro:**

```astro
---
interface Props {
  src: string;
  height?: string;
  showControls?: boolean;
  onLayerClick?: string; // JavaScript function name to call
}

const {
  src,
  height = '400px',
  showControls = false,
  onLayerClick
} = Astro.props;

const mapId = `map-${Math.random().toString(36).slice(2, 9)}`;
---

<div class="interactive-map" id={mapId}>
  {showControls && (
    <div class="map-controls">
      <button class="control-btn" data-action="zoom-in" title="Zoom In">+</button>
      <button class="control-btn" data-action="zoom-out" title="Zoom Out">−</button>
      <button class="control-btn" data-action="reset" title="Reset View">⌂</button>
    </div>
  )}

  <ml-map
    src={src}
    style={`height: ${height}; display: block;`}
    data-click-handler={onLayerClick}
  />

  <div class="map-status"></div>
</div>

<script>
  import '@maplibre-yaml/core/register';
  import 'maplibre-gl/dist/maplibre-gl.css';

  // Initialize all interactive maps
  document.querySelectorAll('.interactive-map').forEach(container => {
    const mapEl = container.querySelector('ml-map');
    const statusEl = container.querySelector('.map-status');
    const controls = container.querySelector('.map-controls');

    if (!mapEl) return;

    let initialCenter: [number, number] | null = null;
    let initialZoom: number | null = null;

    // Status updates
    mapEl.addEventListener('ml-map:load', () => {
      const map = mapEl.getMap();
      initialCenter = map.getCenter().toArray() as [number, number];
      initialZoom = map.getZoom();
      statusEl.textContent = 'Map ready';
      statusEl.className = 'map-status ready';
    });

    mapEl.addEventListener('ml-map:layer-loading', (e: CustomEvent) => {
      statusEl.textContent = `Loading ${e.detail.layerId}...`;
      statusEl.className = 'map-status loading';
    });

    mapEl.addEventListener('ml-map:layer-loaded', (e: CustomEvent) => {
      statusEl.textContent = `${e.detail.featureCount} features loaded`;
      statusEl.className = 'map-status ready';
    });

    mapEl.addEventListener('ml-map:error', (e: CustomEvent) => {
      statusEl.textContent = `Error: ${e.detail.error.message}`;
      statusEl.className = 'map-status error';
    });

    // Custom click handler
    const clickHandler = mapEl.dataset.clickHandler;
    if (clickHandler && typeof window[clickHandler] === 'function') {
      mapEl.addEventListener('ml-map:layer-click', (e: CustomEvent) => {
        window[clickHandler](e.detail);
      });
    }

    // Control buttons
    if (controls) {
      controls.addEventListener('click', (e) => {
        const btn = (e.target as HTMLElement).closest('[data-action]');
        if (!btn) return;

        const map = mapEl.getMap();
        if (!map) return;

        const action = btn.dataset.action;

        switch (action) {
          case 'zoom-in':
            map.zoomIn();
            break;
          case 'zoom-out':
            map.zoomOut();
            break;
          case 'reset':
            if (initialCenter && initialZoom !== null) {
              map.flyTo({ center: initialCenter, zoom: initialZoom });
            }
            break;
        }
      });
    }
  });
</script>

<style>
  .interactive-map {
    position: relative;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid #e5e7eb;
  }

  .map-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .control-btn {
    width: 32px;
    height: 32px;
    border: none;
    background: white;
    border-radius: 4px;
    font-size: 18px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .control-btn:hover {
    background: #f3f4f6;
  }

  .map-status {
    position: absolute;
    bottom: 10px;
    left: 10px;
    padding: 4px 8px;
    background: rgba(255,255,255,0.9);
    border-radius: 4px;
    font-size: 12px;
    z-index: 10;
  }

  .map-status.loading { color: #d97706; }
  .map-status.ready { color: #059669; }
  .map-status.error { color: #dc2626; }
</style>
```

## Content Collections Integration (Optional/Advanced)

For sites with many maps that need build-time validation, you can use Astro Content Collections. Note that this is more complex than the recommended `src` attribute pattern:

**src/content/config.ts:**

```typescript
import { defineCollection, z } from "astro:content";

const maps = defineCollection({
  type: "data",
  schema: z.object({
    type: z.literal("map"),
    id: z.string(),
    config: z.object({
      center: z.tuple([z.number(), z.number()]),
      zoom: z.number(),
      mapStyle: z.string(),
      pitch: z.number().optional(),
      bearing: z.number().optional(),
    }),
    layers: z.array(z.any()),
  }),
});

export const collections = { maps };
```

**src/content/maps/headquarters.yaml:**

```yaml
type: map
id: headquarters
config:
  center: [-122.4194, 37.7749]
  zoom: 15
  mapStyle: "https://demotiles.maplibre.org/style.json"
layers:
  - id: office
    type: circle
    source:
      type: geojson
      data:
        type: Feature
        geometry:
          type: Point
          coordinates: [-122.4194, 37.7749]
        properties:
          name: "Headquarters"
    paint:
      circle-radius: 12
      circle-color: "#3b82f6"
```

**CollectionMap.astro:**

```astro
---
import { getEntry } from 'astro:content';

interface Props {
  slug: string;
  height?: string;
}

const { slug, height = '400px' } = Astro.props;

const mapEntry = await getEntry('maps', slug);

if (!mapEntry) {
  throw new Error(`Map not found: ${slug}`);
}

// Content collection already validates against schema
const configJson = JSON.stringify(mapEntry.data);
---

<ml-map style={`height: ${height}; display: block;`} config={configJson} />

<script>
  import '@maplibre-yaml/core/register';
  import 'maplibre-gl/dist/maplibre-gl.css';
</script>
```

**Usage:**

```astro
<CollectionMap slug="headquarters" height="500px" />
```

## Troubleshooting

### "Expected object, got null" or Similar Schema Errors

**Cause:** YAML indentation was destroyed by template literal processing, or the file couldn't be loaded.

**Solutions:**

1. **Use the `src` attribute pattern** (recommended)

   ```astro
   <Map src="/configs/my-map.yaml" />
   ```

   Place your YAML file in `public/configs/my-map.yaml`

2. **Check browser console for loading errors**

   The web component will log errors if it can't fetch or parse the YAML file.

3. **Verify file path is correct**

   Files in `/public` are served from the root, so `/public/configs/map.yaml` becomes `src="/configs/map.yaml"`

### Map Container Has Zero Height

**Symptoms:** Nothing visible, or map is 0px tall.

**Cause:** CSS height not set properly.

**Solution:**

```astro
<ml-map src="/configs/map.yaml" style="height: 400px; display: block;" />
```

Both `height` and `display: block` are required.

### Map Not Loading from Public Directory

**Symptoms:** `Error: Config not found` or network 404 error

**Cause:** Incorrect path or file not in public directory.

**Solutions:**

1. Ensure file is in `/public` directory (not `/src`)
2. Use root-relative paths: `src="/configs/map.yaml"` for `/public/configs/map.yaml`
3. Check browser network tab for 404 errors
4. Verify file name and extension are correct

### YAML File Changes Not Updating

**Symptoms:** Changes to YAML files in `/public` don't appear immediately.

**Cause:** Browser caching or dev server needs refresh.

**Workaround:**

- Hard refresh the browser (Cmd+Shift+R or Ctrl+Shift+R)
- Or restart the dev server
- Note: Files in `/public` are served statically, so they update immediately without rebuild

### TypeScript Errors with `import.meta.glob`

**Solution:** Add to `src/env.d.ts`:

```typescript
/// <reference types="astro/client" />

declare module "*.yaml" {
  const content: string;
  export default content;
}
```

### Web Component Not Defined

**Symptoms:** `<ml-map>` renders as unknown element.

**Cause:** Registration script didn't run.

**Solution:** Ensure script is in component:

```astro
<script>
  import '@maplibre-yaml/core/register';
  import 'maplibre-gl/dist/maplibre-gl.css';
</script>
```

The script must be inside the component, not in the frontmatter.

## Best Practices Summary

<CardGrid>
  <Card title="Use src Attribute (Recommended)" icon="document">
    Place YAML files in `/public/configs/` and use `<ml-map src="/configs/map.yaml">`. Simplest and most maintainable approach.
  </Card>

  <Card title="Set Explicit Dimensions" icon="seti:css">
    Always set `height` and `display: block` on `<ml-map>` elements.
  </Card>

  <Card title="Keep Config Separate" icon="approve-check">
    Avoid inline YAML in components. External files are easier to edit and maintain.
  </Card>

  <Card title="Use Build-Time Validation (Optional)" icon="warning">
    For critical applications, parse YAML at build time (Pattern 2) to catch errors early.
  </Card>
</CardGrid>

## Next Steps

- [Vanilla JavaScript Integration](/integrations/vanilla-js/) - For non-Astro projects
- [Web Components Reference](/integrations/web-components/) - Deep dive into `<ml-map>`
- [Live Data Guide](/guides/live-data/) - Polling and streaming
- [API Reference](/api/) - Complete API documentation
